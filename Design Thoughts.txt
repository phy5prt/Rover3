Working on rovermanager execute rovers

0.identify which dictionary a command was in in order to know how to execute it 
Report Class report individual rover position and all rover positions
1. 
2. 
3. Rovers check so dont crash
4. RoverDictionary makes a report from the rover report - maybe interface or abstrace so that it can either pass on rover response or it could just send the list userinterface could just publish the list
4. have commands hold descriptions of themselves
4. have seperate orientation dictionary and move dictionary but still abstract as command
4. have rover command dictionary create destroy
4. maybe dictionary or dictionaries so can check the dictionaries for key presses without having to make a switch e.g availableKeyPress dictionary to enable chosing which type of commands to run
4. Revise design pattern command put notes in the file
5. Revise other relevant design patterns
6. Make changes or just make notes on how would implement:
	*left right sideways movement
	*classes holding own key and all data for setting up the dictionary
	*dictionaries build themselves from children of a class
	*part ordinates face left or right. vs step left right vs turn to next ordinate left or right - up and down an enum in order of angle around compass
7. Tidy it up so works smooth english correct
8. Put it online

//will need to handle error if something gets through to manager that isnt in dictionary

//learning about error handling what to wrap in try get and what not to will be important

//who should be responsible to checking if space available rover checks with manager only to tell manager or rover send up a move at a time

//question of passing rover string or single char

//rover manages what movement looks like rover manager says if it is allowed 

chang command to moveCommands change look to face.



To do the enum of the left to right would need to give each look command a angle and then build enum in that
order them by that then left by right. Then can when new ordinates made eg NE then it will be inserted in the right order

Move Left Move Right Turn Left One Ordinate, Turn Right One ordinate


My understanding of Get Set and this needs revising look at the Location interface and constructor then research

Should build own dictionary still

This is not exactly command pattern could i make it more like it - go back and watch command pattern stuff

LookNorth could be just look if it took an orientation object, 
the type of object could be set in the dictionary but it would then have a different signature

still struggling with open close principle and setting the key presses

trying to make it so only need add class in one place to need it 

if want to do left and right could do an enum for the directions cycle through them and loop round
-maybe next rover

multiple rovers - 1-2-3-4 to set up, check if they are going to crash- next phase


View user interface control the command model the rovers and the positions - could mvc be appplicable?

Commands should have their own key in their class that the dictionary takes, and a description so that the dictionary can get the classes 
and build itself and the keys, it should also be able to when user interface goes through the commands provide a description of what each does

should the rover force checking of valid command sequence in its method to stop later it being called without or because it is not the brain should it just rely on one always being called then the other
I think the answer will be to do with errors and validation

string builder look into

does dictionary adding the to it break open close principle

To add move leftwards and rightwards movement would need to put in a order to NESW with enum or array and then loow if going W to N
Would get current location orientation and use the orientation one less or one more depending if want right or left movement

Need to protect  my fields  more theyre often public rather than private with get set

useInterfaceInstruction

command to get a list of all available commands

it would be nice if could make a long string moving each rover e.g 1NMM2NSS  - but would you cut and validate as individual strings or bring back a fail if get to last rover and it goes out of bounds

make program so can quit anytime even if part way through a method eg creating a rover

//Chose initial orientation for your rover
            //I cant use this :
            //string.Join(" ", StaticMoveCommandFactoryDic.commandKeys.Keys.ToArray());
            //because it would include the movement commands
            //so if I wanted to create a ne orientation i would have to alter this code
            //which suggests they should be two different dictionaries
            //or that each method should hold its own description of what it does and the interface can the just get the keys
            //and the description and put them up
            //best solution is seperate dictionary but still good idea to have a description in the commands

//CommandFactory is static but if rovers were later required to have different commands
    //I would need to drop the static and give them own dictionaries
    //or make a static command dictionary factory that builds custom dictionaries to initialise
    //rovers with



	Revise (lambda) context this:
	static StaticCommandFactoryDic() {
            var commands = Assembly.GetAssembly(typeof(Command)).GetTypes()
                .Where(myCommand => myCommand.IsClass && !myCommand.IsAbstract && myCommand.IsSubclassOF(typeof(Ability)));
        }

		Is it possible to have a folder and just ask the dictionary to put all classes in the folder into  itself? or a namespace?





		
            Orientation newRoverOrientation; // this does work because have no was of setting an orientation just of applying one 
            //to a current locationInfor
            //therefore will need to make a location Information and then apply the command face east to overide our default
            //this may be bad design so maybe I should be setting all orientations based on degrees or radians starting north

            //We have to initialise a location with default values and overwrite it because we can over write an orientation but we have now way of just making one

should useInterface do all talking and make an object for managing rovers



		When request feedback:
		how order folders 
		how add to userInterface despite open close e.g. a report command saying where all rovers are


		Orientation movement information could be built in to FaceEast etc maybe or not it needs to remember direction is facing, ... 
		but that could just be that location info holds an orientation delegate
		... would that still work if later wanted to move left you would look at the delegate and change it accordingly
		...FaceLeft FaceRight would be relative movements they would check change orientation delegate. StepLeft, StepRight would do the same but also execute the delegate.
		Former orientation commands the latter movement command but inherit same abstract just in different dictionaries, as will seperate them
		//this would mean on set up can just delegate by letter when creating the rover insteadof overwriting
		//how would this work with getting report you are facing left-- dictionary if holding functions not objects then more sections, this wont be command anymore
		//"Key", "Instruction string e.g. command makes the rover FaceLeft ... or stepLeft"
		//so maybe command for movements, delegate for orientations

		        Rover selectedRover;// = new Rover(new LocationInfo(new North(), 0, 0, 0, 10, 0, 10));
        //maybe dictionary should hold this and getter and setter should alter the selectedRover
        //or being an object will changes translate anywya
        //maybe should store test rover here too 
        //and make dictionary rover manager


		//should rover move itself or should it be moved, should it test itself

		//seperate test and rover because actual movement would involve more than checking route

		//userinterface should look make sure command string only has commands from rover manager and orientation in then pass it on
		//user interface should be for validating and then passing on the instructions not executing them



		the destroy rover command could use a rover destructor which removes it from dic and destroy it
		for test it could just remove itself from the dictionary
		removed rovers could be readded at the end of the test
		-where should responsibility lie from removing from the dictionary and destroying
		-maybe removing from dictionary is dictionaries responsibility and destroy is rovers 
		-need to look into whether destroy would fit abstract command pattern
		-no it shouldnt because those commands are all about move actions 

		overload the add opperator for add report responses from rover

		//should task validation be an interface?



		// next project his using matrixes
		//building the n-unit tests to see around the existing program