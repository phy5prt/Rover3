


TODO this next step is to make this function work to support the above


-- select single key for rover allows more than one key
-- no such rover - key not recognised -- improve text strings generally
-- do unit tests
-- do not seperate interface and move commands allow both to be done in same string


-- update method for checking if keys are available to use dictionary
-- look into alternatives for statics, and look at partial classe
-- change report to a different word so key doesnt clash with right
--research methods for associating a method with a key press

--numbers can be handled as multipliers by the consolerhandler --- putting in letter for numbers, and taking out again -- unless asterixes in that section

--left and right implemented
--scienceAction commands e.g. sample soil, air, -- store data and then map report for soil, air, -- obstacles
--introduce unexpected obstacle -- known and unknow sectors -- when one rover hits obstacle all should stop and wait for further instruction -- return what of string executed and what not
--write tests
--refactor each class
--update umc chart relationships
--can we should we, replace all the movement orientation classes with one class that has variables for setting positive or negative for how it alters location coordinates, and create an instance with each version
--review the difference between userinterface inteface keys class which uses hiding  and others which sety valuie in getter 
--Review purpose of classes in light of new design requirement doc, validation having too much and location information having too much is a risk
--redo rover manager now multipe rovers create list of rovers and their strings run them - if any fail reset all rovers in list test locations -- check locations against test locations of every rover in dictionary(just movements)
 *********Need a locationInformation interface and then both validating and executing can have the interface and the report of an route error or route exection will take an object of that interface
 *********Or reporting has two methods depending on the input it takes validation for a fail and it takes location for a success -- could still use interface

		--- location info now holds what it is info for, so could just make every location info that is made add itself to a list, 
		--- but we store the previous location of moving objects so with a bool for historic
		--- and a destroy create for populating the list
		--- currently use classes but structs are value types, consider passing refs, or structs instead -- but then would we beable to change a location to historic, or testLocation and it update in the list ... no
		
		--check range is positive when set up

		---locationInfo should be passed instead of validation -> if fail pass the location info of the fail, if succeed pass the list of moves --- (do this by having the execute command create a location information list (and also update the main list)
--- would need list of location executed, and last executed, the latter being the ones from the just executed command string
---the correct constructor may work. 



---->locationInfo and orientation are classes but this means copying them requires cloning - read up on cloning, using structs insted or passing references
-- key behaviour is to be able to copy them and then revert. for testing the routes

-- to revert have location startlocation, revertlocation, . set location = startlocation, var revertlocation = startlocation, do what you need to do to location then if it fail startlocation = revertlocation
https://stackoverflow.com/questions/7477073/made-one-instance-of-a-class-equal-to-another-how-to-cancel-that

----------------------------------------------------------------------------------------------------***********-----





//next steps get working with code smells


//bug can set rover name to s on creation

//ReportLocationSingleRover() - this needs to take a rover, and be run through the dictionary - or be given the rover names in order they were in, last rover it says currently selected rover

//put in if check if any rovers if not reports message currently no rovers press c to create one or q to exit


		//no longer reports where rover would cross bound
		//does not correctly select element of string that caused the issue in the command
		//Rover selected not reset if command execution fails due to out of bound so if go rover a then rover s FFFFFFF it wont move either but will change to rover s
//give dictionaries names - in their abstract class
//then get working with dictionaries created from namespaces and held by the MoveCommand Dictionary
//consider if rover dictionary and move command manager dictionary should be held together
//Get L and R working by using the list of orientations
//improve user interface using all string builder
//improve reports make for all rovers reporter
//make individual rover reports show the boundaries of each rover
//make rovers not allowed to take up the same space



//structure MoveCommands, driveCommands, FaceCommand, TurnCommands (face is objective, turn is relative) - putting in seperate dictionaries and names spaces just so can seperate them for how user interface represents them seems excessive, another way of distinguishing them

//why dictionary of dictionaries why not something else, a list for example?
//why not one dictionary that grabs all movement types but those types are in own namespace so can be checked for name space if userinterface wants to seperate them by type e.g. move and face commands

//constructor for report when make everything private then add reports?

//look at removing rovervalidation tasks and command key validation and replacing with a report and plan the class

//start basic
//just add the report string
//just get overall success with the bool

//add rover reports then have user interface do something with them. 



//Tidy whole program of comments - maybe draw design document (once done interface)

Working on userinterface
should be able just to report when press return
should be able to process multiple reports by overriding the + indicator - DECIDED NO !

Dictionary of dictionaries that use keys (who in charge displaying all the keys) - dictionaries should hold their own name string

should give all keys at the begining 
should give all keys aftwr making a rover
should give proper message for keys

//do report class remembers location and ... or if rover had their last report ... should we be even adding the reports

0.identify which dictionary a command was in in order to know how to execute it 
Report Class report individual rover position and all rover positions
1. 
2. 
3. Rovers check so dont crash
4. RoverDictionary makes a report from the rover report - maybe interface or abstrace so that it can either pass on rover response or it could just send the list userinterface could just publish the list
4. have commands hold descriptions of themselves Tick
4. have seperate orientation dictionary and move dictionary but still abstract as command
4. have rover command dictionary create destroy
4. maybe dictionary or dictionaries so can check the dictionaries for key presses without having to make a switch e.g availableKeyPress dictionary to enable chosing which type of commands to run
4. Revise design pattern command put notes in the file
5. Revise other relevant design patterns
6. Make changes or just make notes on how would implement:
	*left right sideways movement
	*classes holding own key and all data for setting up the dictionary
	*dictionaries build themselves from children of a class
	*part ordinates face left or right. vs step left right vs turn to next ordinate left or right - up and down an enum in order of angle around compass
7. Tidy it up so works smooth english correct
8. Put it online
script explaining design
youtube
website
explanatory document

//will need to handle error if something gets through to manager that isnt in dictionary

//learning about error handling what to wrap in try get and what not to will be important

//who should be responsible to checking if space available rover checks with manager only to tell manager or rover send up a move at a time

//question of passing rover string or single char

//rover manages what movement looks like rover manager says if it is allowed 

chang command to moveCommands change look to face.



To do the enum of the left to right would need to give each look command a angle and then build enum in that
order them by that then left by right. Then can when new ordinates made eg NE then it will be inserted in the right order

Move Left Move Right Turn Left One Ordinate, Turn Right One ordinate


My understanding of Get Set and this needs revising look at the Location interface and constructor then research

Should build own dictionary still

This is not exactly command pattern could i make it more like it - go back and watch command pattern stuff

LookNorth could be just look if it took an orientation object, 
the type of object could be set in the dictionary but it would then have a different signature

still struggling with open close principle and setting the key presses

trying to make it so only need add class in one place to need it 

if want to do left and right could do an enum for the directions cycle through them and loop round
-maybe next rover

multiple rovers - 1-2-3-4 to set up, check if they are going to crash- next phase


View user interface control the command model the rovers and the positions - could mvc be appplicable?

Commands should have their own key in their class that the dictionary takes, and a description so that the dictionary can get the classes 
and build itself and the keys, it should also be able to when user interface goes through the commands provide a description of what each does

should the rover force checking of valid command sequence in its method to stop later it being called without or because it is not the brain should it just rely on one always being called then the other
I think the answer will be to do with errors and validation

string builder look into

does dictionary adding the to it break open close principle

To add move leftwards and rightwards movement would need to put in a order to NESW with enum or array and then loow if going W to N
Would get current location orientation and use the orientation one less or one more depending if want right or left movement

Need to protect  my fields  more theyre often public rather than private with get set

useInterfaceInstruction

command to get a list of all available commands

it would be nice if could make a long string moving each rover e.g 1NMM2NSS  - but would you cut and validate as individual strings or bring back a fail if get to last rover and it goes out of bounds

make program so can quit anytime even if part way through a method eg creating a rover

// Dictionaries, Drive, Face, Turn, UserInterfacecommand - but how will drive face and turn reflectively build themselves? - use namespaces?

//Chose initial orientation for your rover
			//I cant use this :
			//string.Join(" ", StaticMoveCommandFactoryDic.commandKeys.Keys.ToArray());
			//because it would include the movement commands
			//so if I wanted to create a ne orientation i would have to alter this code
			//which suggests they should be two different dictionaries
			//or that each method should hold its own description of what it does and the interface can the just get the keys
			//and the description and put them up
			//best solution is seperate dictionary but still good idea to have a description in the commands

//CommandFactory is static but if rovers were later required to have different commands
	//I would need to drop the static and give them own dictionaries
	//or make a static command dictionary factory that builds custom dictionaries to initialise
	//rovers with



	Revise (lambda) context this:
	static StaticCommandFactoryDic() {
			var commands = Assembly.GetAssembly(typeof(Command)).GetTypes()
				.Where(myCommand => myCommand.IsClass && !myCommand.IsAbstract && myCommand.IsSubclassOF(typeof(Ability)));
		}

		Is it possible to have a folder and just ask the dictionary to put all classes in the folder into  itself? or a namespace?





		
			Orientation newRoverOrientation; // this does work because have no was of setting an orientation just of applying one 
			//to a current locationInfor
			//therefore will need to make a location Information and then apply the command face east to overide our default
			//this may be bad design so maybe I should be setting all orientations based on degrees or radians starting north

			//We have to initialise a location with default values and overwrite it because we can over write an orientation but we have now way of just making one

should useInterface do all talking and make an object for managing rovers



		When request feedback:
		how order folders 
		how add to userInterface despite open close e.g. a report command saying where all rovers are


		Orientation movement information could be built in to FaceEast etc maybe or not it needs to remember direction is facing, ... 
		but that could just be that location info holds an orientation delegate
		... would that still work if later wanted to move left you would look at the delegate and change it accordingly
		...FaceLeft FaceRight would be relative movements they would check change orientation delegate. StepLeft, StepRight would do the same but also execute the delegate.
		Former orientation commands the latter movement command but inherit same abstract just in different dictionaries, as will seperate them
		//this would mean on set up can just delegate by letter when creating the rover insteadof overwriting
		//how would this work with getting report you are facing left-- dictionary if holding functions not objects then more sections, this wont be command anymore
		//"Key", "Instruction string e.g. command makes the rover FaceLeft ... or stepLeft"
		//so maybe command for movements, delegate for orientations

				Rover selectedRover;// = new Rover(new LocationInfo(new North(), 0, 0, 0, 10, 0, 10));
		//maybe dictionary should hold this and getter and setter should alter the selectedRover
		//or being an object will changes translate anywya
		//maybe should store test rover here too 
		//and make dictionary rover manager


		//should rover move itself or should it be moved, should it test itself

		//seperate test and rover because actual movement would involve more than checking route

		//userinterface should look make sure command string only has commands from rover manager and orientation in then pass it on
		//user interface should be for validating and then passing on the instructions not executing them



		the destroy rover command could use a rover destructor which removes it from dic and destroy it
		for test it could just remove itself from the dictionary
		removed rovers could be readded at the end of the test
		-where should responsibility lie from removing from the dictionary and destroying
		-maybe removing from dictionary is dictionaries responsibility and destroy is rovers 
		-need to look into whether destroy would fit abstract command pattern
		-no it shouldnt because those commands are all about move actions 

		overload the add opperator for add report responses from rover

		//should task validation be an interface?

		//for own simplicity have made long string command short string instruction but this is not necessary
		//later version if letter is not in the command dictionary but it is in other dictionary it runs it --No because will still be testing
		--could slice long command string up and report back "Command string 1 exectute then report""command string 2 execute then report" so all though
		it is only one in put it should cut it up and receive it as an array of seperate commands

		/// next version should not move distinct ammounts but degrees and meters

		/////////////should console useroutput when shows user what they typed seperate it into command string and interface letters so they can see
		//should acceptnumbers for f100 which mean f 100 times


							doing lots of loops and things twice because of testing the route is there a way to reduce this

		I could execute a substring per test this would mean not having to remember when they are incase they crash

		
		interface KeyInputs use reflection  to do this - all have string that is their key all have a string what key does - key for bringing up list instructions, rovers and commands

		Choose words per string e.g. inputString roverCommandString instructionsString

		//if i combine the below save in notes i have see if it is good decision - single repsonsibility principle.
		commandkey validation method and rovertasksvalidation maybe should be the same object compare with checkprocessusercommand input


		// get and set could it just be private string instruction without get and set? = Dictionary keys + Move keys

		//should it be executing per successful rover my design choice was no

		//should i pass only string builders and make them into string in conolewriteline

		revise get set
		revise interface with abstract
		revise hiding with abstract
		do solo learn again
		
		Next proj
		Linq, sql, - could use multi delegate matrix version rover with sql some how get advice



		//for something like this:

		  private string Instructions
		{
			get
			{
				//C create, D destroy,
				StringBuilder instructions = new StringBuilder(300);
		instructions = String.Format("Input single characters to activate user commands. " +
					"Q to quit. (Dictionary here) C to create. Input return with no characters to get a full report on all rovers. " +
					"To give rovers commands input the rover you wish to command followed by the command letters you wish it to execute." +
					"For example to move rover T forward, rover Y backward and Face rover U east type TFYBUE. If rover T is the currently selected rover you can type FYBUE." +
					insertline
					"Rovers  : " + string.Join(" ", StaticMoveCommandFactoryDic.commandKeys.Keys.ToArray()) + 
					insertline
					"Commands: " + string.Join(" ", RoverManagerStatic.RoverDictionary.Keys.ToArray()));
				return this._instructions.ToString();
			}
		}
		it would nice to have a set that automatically updates when ever dictionaries changed --- not necessary here
		
		//but would be nice to know if can - but think needs listners

		//getter setter when to use method or get set
		https://stackoverflow.com/questions/601621/properties-vs-methods
		https://docs.microsoft.com/en-us/previous-versions/dotnet/netframework-4.0/ms229054(v=vs.100)?redirectedfrom=MSDN


		//So if dynamically creating an enum is hard what is the alternative a dictionary with int 

		//how to structure name spaces
		//keep list questions like this somewhere so remember to ask ppl - git?

		difference between names space and modules

		would like to get rid of this var          var turnCommands = Assembly.GetAssembly(typeof(MoveCommand)).GetTypes()

		really need to go over naming conventions for names space class method dic interface, capitalisation and verb noun namesetc

		//yuck hardcoded ---                   .Where(driveCommand => driveCommand.IsClass && !driveCommand.IsAbstract && driveCommand.IsSubclassOf(typeof(MoveCommand))&& (driveCommand.Namespace == "DriveCommandsNS")); 


		//model rover taking photos discovering obstical and doing various types of samples and get result with random generator to model it
		//this will give us a reason for a database and SQL


		//static class DriveCommandsDicCS : MoveCommandDicAbs doesnt work cannot use a base class for static
		namespace Rover3.MoveCommands
	//This doesn't seem right an empty abstract just so can grab dictionaries through reflection
	//should this class actually make those dictionaries in their name spaces
	abstract class MoveCommandDicAbs

	//could make a public static list that is part of each dictionary that they add to with creation - as they all have it seems like it could be from abstract


	could put all givtioanries into dictionary manager but that seems against open close cant just add new dictionary
	//also how give the dictionaries name if name stic all will be static

	//does this mean singleton pattern insted
	
	//dictionaries could be made by static dictionary manager constructor
	//each dictionary could be produced from the namespace
	//from a abstract class with dictionary class
	//in a dictionary themselves and the key could be the name of the dic <string dic name = key,value = dic>
	//Or dic could hold the name itself and be in list 
	//---> result foreach dic in dicmanager via list/dic print dic name from key or object itself then its commands with their keyboard keys


	  //instead of having to check dictionary and pass the rover should task validation be able to provide info for report
				//Or contain the rover the have validated
				//or should the rover hold its last task validation - would need to be a list if it is called multiple time in a command string


				//validate command sequence should return a list aswell or return the list of rovers so you know none moved






				------------------------------Bugs-----------------------------
				you can call your rover q, and if you do you can move it but you press a single q and it quits, use the dictionaries to disallow in use keys as names



				-=-----rememeber command strings so can undo and redo  (deletions will be an issue)
